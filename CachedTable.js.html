<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: CachedTable.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: CachedTable.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

/**
 * Create an abstraction of any range of a Google spreadsheet so that read and writes to it
 * are much faster when the cache is turned on.  All methods in ctTable are wrapped and prefixed with 'ct'.
 * We call this a CachedTable.
 *
 * @constructor
 * @param {integer} row - Starting row number of the section
 * @param {integer} col - Starting col number of the section
 * @param {integer} rowlast - Ending row number of the section
 * @param {integer} collast - Ending column number of the section
 * @param {string} sheetname - Name of the worksheet containing this section
 * @param {boolean} UseCache - Set to true if you want to use the cache (recommended)
 * @returns {Object} The ctTable functions.
 */
function ctTable( row, col, rowlast, collast, sheetname, UseCache ) {

  var rowStart = row;
  var rowEnd = rowlast;
  var colStart = col;
  var colEnd = collast;
  var currRow;
  var sheet = SpreadsheetApp.getActive().getSheetByName(sheetname);
  var _cache= false;
  
  if( UseCache !== undefined &amp;&amp; UseCache === true )
      _cache = new cache_( row, col, rowlast, collast );
  
  return {

      init: function() {
      
          currRow = rowStart-1;
          
          if( _cache )
              _cache.init(sheet.getRange(rowStart, colStart, 
                          rowEnd-rowStart+1,colEnd-colStart+1).getValues());
          return this;
      },
      
      nextRow: function() {
 
          currRow++;        
          if( currRow === rowEnd+1 )        
              return null;            
          else{
              if( _cache )
                  return _cache.nextRow();
              else
                  return sheet.getRange(currRow, colStart, 1, colEnd-colStart+1).getValues();
          }
      },
      
      /* return current row index starting from rowStart
         this function is usually paired with nextRow */
      getRowIndex: function() {
      
          return currRow === (rowStart-1)? rowStart:currRow;
      },
      
      // incoming indices start from 1
      getRow: function(i) {
 
          var row=i;                     
          if( row >= rowStart &amp;&amp; row &lt;= rowEnd ){
          
              if( _cache )
                  return _cache.getRow(row);
              else
                  return sheet.getRange(row, colStart, 1, colEnd-colStart+1).getValues();
          }
          
          throw new Error("getRow: Out of table bounds!");
      },
      
      setRow: function(i,obj){
      
          if( Array.isArray(obj) ){
          
              if( Array.isArray(obj[0]) )
                  obj = obj[0];
              
              if( obj.length !== (colEnd - colStart + 1) )
                  throw new Error("setRow: obj exceeds length of table.");
                       
              if( i >= rowStart &amp;&amp; i &lt;= rowEnd ){
  
                  if( _cache )
                      _cache.storeRow(i,obj);    
                  else
                      sheet.getRange(i, colStart, 1, colEnd - colStart + 1).setValues([obj]);
                      
                  return this;
              }else
                  throw new Error("setRow: index exceeds table bounds.");             
          }else
              throw new Error("setRow: Non-array obj as value!");
      },
      
      setValue: function(i,j,obj){
      
          if( !Array.isArray(obj) ){
          
              if( i >= rowStart &amp;&amp; i &lt;= rowEnd &amp;&amp;
                  j >= colStart &amp;&amp; j &lt;= colEnd ){  
                  
                  if( _cache )
                      _cache.storeValue(i,j,obj);
                  else
                      sheet.getRange(i,j).setValue(obj);
                      
                  return this;
               }else
                   throw new Error("setValue: Out of table bounds!");             
          }else
              throw new Error("setValue: Array obj as cell value!");
      },

      getValue: function(i,j){
          
           if( i >= rowStart &amp;&amp; i &lt;= rowEnd &amp;&amp;
               j >= colStart &amp;&amp; j &lt;= colEnd ){  
                  
               if( _cache )
                   return _cache.getValue(i,j);
               else
                   return sheet.getRange(i,j).getValue();
                  
           }else
               throw new Error("getValue: Out of table bounds!");             
      },
      
      rows: function() {
          return (rowEnd - rowStart + 1);
      },
      
      columns: function() {
          return (colEnd - colStart + 1);
      },
      
      flushAll : function(){
      
          if( _cache === false )
              return this;
              
          sheet.getRange(rowStart, colStart, 
          rowEnd-rowStart+1, colEnd-colStart+1).setValues(_cache.getObjects());
          
          SpreadsheetApp.flush();
          return this;
      }
  };
}

function cache_( row, col, rowlast, collast ) {

  // In this cache, all indices start from 0
  var rowStartActual = row;
  var colStartActual = col;
  
  var rowStart = 0;
  var rowEnd = rowlast - row;
  var colStart = 0;
  var colEnd = collast - col;
  var currRow;
  var store = [];
  
  return {

      init: function(objArray) {
      
          if( objArray === undefined ){
          
              var sizeRows = rowEnd - rowStart + 1;
              for( var i=0; i&lt;sizeRows; i++ )
                   store[i] = new Array(colEnd - colStart + 1);
          }else
              store = objArray;
          
          if( Array.isArray(objArray) &amp;&amp; Array.isArray(objArray[0]) ){
          
              if( objArray.length !== (rowEnd-rowStart+1) )
                  throw new Error("cache init: incorrect row count.");
              
              if( objArray[0].length !== (colEnd-colStart+1) )
                  throw new Error("cache init: incorrect column count.");
          }else
              throw new Error("cache init: non 2-dimensional array passed.");
          
          currRow = rowStart;
          return this;
      },
      
      nextRow: function() {
 
          if( currRow === rowEnd+1 )
          
              return null;
          else
              return store[currRow++];
      },
      
      // outgoing index values are also starting from rowStartActual
      getRowIndex: function() {      
          return currRow+rowStartActual;
      },
      
      // incoming index will be starting from rowStartActual
      getRow: function(i) {
 
          var row = i-rowStartActual;                     
          if( row >= rowStart &amp;&amp; row &lt;= rowEnd )
              return store[row];
          
          throw new Error("getRow: Out of cache bounds!");
      },
      
      // incoming indices start from rowStartActual
      storeRow: function(i,obj){
      
          var row = i-rowStartActual;
          if( Array.isArray(obj) ){
          
                if( Array.isArray(obj[0]) )
                    obj = obj[0];
                
                if( obj.length !== (colEnd - colStart + 1) )
                    throw new Error("storeRow: obj length exceeds cache size.");
                         
                if( row >= rowStart &amp;&amp; row &lt;= rowEnd ){
                    store[row] = obj;
                    return this;
                }
          }
          throw new Error("storeRow: trying to store non array.");
      },
      
      storeValue: function(i,j,value){
      
          var row = i-rowStartActual;
          var col = j-colStartActual;
          if( row >= rowStart &amp;&amp; row &lt;= rowEnd &amp;&amp;
              col >= colStart &amp;&amp; col &lt;= colEnd ){            
                  
              store[row][col] = value;
              return this;
          }
          
          throw new Error("storeValue: Out of cache bounds!");
      },

      getValue: function(i,j){

          var row = i-rowStartActual;
          var col = j-colStartActual;
          if( row >= rowStart &amp;&amp; row &lt;= rowEnd &amp;&amp;
              col >= colStart &amp;&amp; col &lt;= colEnd )
              return store[row][col];
  
          throw new Error("getValue: Out of cache bounds!");
      },
      
      rows: function() {
          return (rowEnd - rowStart + 1);
      },
      
      columns: function() {
          return (colEnd - colStart + 1);
      },
      
      getObjects: function() {
          return store;
      }
  };
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ctTable.html">ctTable</a></li><li><a href="Stopwatch.html">Stopwatch</a></li><li><a href="Trigger.html">Trigger</a></li><li><a href="TriggerManager.html">TriggerManager</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ctColumns">ctColumns</a></li><li><a href="global.html#ctFlushAll">ctFlushAll</a></li><li><a href="global.html#ctGetRow">ctGetRow</a></li><li><a href="global.html#ctGetRowIndex">ctGetRowIndex</a></li><li><a href="global.html#ctGetValue">ctGetValue</a></li><li><a href="global.html#ctInit">ctInit</a></li><li><a href="global.html#ctNextRow">ctNextRow</a></li><li><a href="global.html#ctRows">ctRows</a></li><li><a href="global.html#ctSetRow">ctSetRow</a></li><li><a href="global.html#ctSetValue">ctSetValue</a></li><li><a href="global.html#onEditTest">onEditTest</a></li><li><a href="global.html#TestCachedTable">TestCachedTable</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Tue Apr 21 2020 18:23:24 GMT+0800 (Taipei Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
